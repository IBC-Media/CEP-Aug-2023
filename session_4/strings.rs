fn main(){
    // creating a new string
    // 1. create a empty string and pass value into it
    let mut s = String::new();
    // 2. take a &str and convert it into a string

    // &str
    let data = "initial contents";
    // &str -> String
    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();

    // 3. using the string::from function
    let s = String::from("initial contents");


    // updating a string 
    let mut s1 = String::from("foo");
    let s2 = "bar"; //&str
    s1.push_str(s2);
    println!("s1 is {s1}");

    // combining strings
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}"); //tic-tac-toe
    // using format! is much easier to read, and the code generated by the format! macro uses references so that this call doesn’t take ownership of any of its parameters.

    // indexing is not permitted in rust
    // rather we will use slicing

    // each character takes 2 bytes
    let hello = "Здравствуйте";
    let s = &hello[0..4];

    println!("s is {}",s );


    // we can see the difference of the byte representation and the charactre representation using the .chars and .bytes method

    for c in "Зд".chars() {
        println!("{c}");
    }

    for b in "Зд".bytes() {
        println!("{b}");
    }
}